/*
 * Copyright 2016 Maikel Nadolski
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#ifndef HMM_IO_H_
#define HMM_IO_H_

#include <map>
#include <istream>
#include <Eigen/Dense>
#include <gsl_assert.h>
#include <range/v3/all.hpp>
#include <iostream>

#include "maikel/hmm/hidden_markov_model.h"
#include "maikel/function_profiler.h"

namespace maikel { namespace hmm {

  struct getline_error: public std::runtime_error {
      getline_error(std::string s): std::runtime_error(s) {}
  };

  struct read_ascii_matrix_error: public std::runtime_error {
      read_ascii_matrix_error(std::string s): std::runtime_error(s) {}
  };

  struct read_sequence_error: public std::runtime_error {
      read_sequence_error(std::string s): std::runtime_error(s) {}
  };

  inline std::istream& getline(std::istream& in, std::istringstream& linestream)
  {
    Expects(in);
    std::string line;
    if (!std::getline(in, line))
      throw getline_error("Could not read the line from given stream.");
    linestream.str(line);
    linestream.clear();
    return in;
  }

  template <class size_type>
    std::pair<size_type, size_type> getdims(std::istream& in)
    {
      Expects(in);
      std::pair<size_type, size_type> dim;
      std::istringstream line(ranges::front(ranges::getlines(in)));
      if (!(line >> dim.first >> dim.second))
        throw read_ascii_matrix_error("Could not read dimensions.");
      return dim;
    }

  template <class float_type>
    typename std::enable_if<
        std::is_floating_point<float_type>::value,
    Eigen::Matrix<float_type, Eigen::Dynamic, Eigen::Dynamic>>::type
    read_ascii_matrix(std::istream& in, std::size_t rows, std::size_t cols)
    {
      Expects(in);
      typename Eigen::Matrix<float_type, Eigen::Dynamic, Eigen::Dynamic> matrix(rows, cols);
      std::istringstream line;
      for (std::size_t i = 0; i < rows; ++i) {
        getline(in, line);
        for (std::size_t j = 0; j < cols; ++j)
          if (!(line >> matrix(i,j)))
            throw read_ascii_matrix_error("Could not read entries in line: " + line.str() + ".");
      }
      Ensures(gsl::narrow<std::size_t>(matrix.rows()) == rows &&
              gsl::narrow<std::size_t>(matrix.cols()) == cols);
      return matrix;
    }

  template <class Derived>
    Eigen::DenseBase<Derived>& normalize_rows(Eigen::DenseBase<Derived>& matrix)
    {
      using Index = typename Eigen::DenseBase<Derived>::Index;
      for (Index i = 0; i < matrix.rows(); ++i)
        matrix.row(i) /= matrix.row(i).sum();
      return matrix;
    }

  template <class float_type>
    typename std::enable_if<
        std::is_floating_point<float_type>::value,
    hidden_markov_model<float_type>>::type
    read_hidden_markov_model(std::istream& in)
    {
      Expects(in);
      using matrix     = typename hidden_markov_model<float_type>::matrix;
      using row_vector = typename hidden_markov_model<float_type>::row_vector;
      using index      = typename hidden_markov_model<float_type>::size_type;
      index states;
      index symbols;

      std::tie(states, symbols) = getdims<index>(in);
      matrix A  = read_ascii_matrix<float_type>(in, states, states);
      matrix B  = read_ascii_matrix<float_type>(in, states, symbols);
      row_vector pi = read_ascii_matrix<float_type>(in, 1, states);
      normalize_rows(A);
      normalize_rows(B);
      normalize_rows(pi);

      Ensures(A.rows() == states && A.cols() == states);
      Ensures(B.rows() == states && B.cols() == symbols);
      Ensures(pi.rows() == 1 && pi.cols() == states);
      return hidden_markov_model<float_type>(A, B, pi);
    }

  template <class float_type>
    typename std::enable_if<
        std::is_floating_point<float_type>::value,
    void>::type
    print_model_parameters(std::ostream& out, hidden_markov_model<float_type> const& model)
    {
      out << "N= " << model.states() << "\n";
      out << "M= " << model.symbols() << "\n";
      out << "A:\n" << model.A << "\n";
      out << "B:\n" << model.B << "\n";
      out << "pi:\n" << model.pi << "\n";
      out << std::flush;
    }

  template <class size_type>
    size_type read_sequence_length(std::istream& in)
    {
      std::string line;
      std::getline(in, line);
      std::istringstream linestream(line);
      size_type length;
      linestream >> length;
      return length;
    }

  template <class Integral, class Symbol>
    std::vector<Integral>
    read_sequence(std::istream& in, std::map<Symbol,Integral>& symbol_to_index)
    {
      MAIKEL_PROFILER;
      std::vector<Integral> sequence;
      sequence.reserve(read_sequence_length<std::size_t>(in));
      auto symbol_map = [&symbol_to_index] (Symbol const& symbol) {
          auto found = symbol_to_index.find(symbol);
          if (found == symbol_to_index.end())
            throw read_sequence_error("Unkown Symbols in Input.");
          return found->second;
      };
      auto sequence_input = ranges::istream_range<Symbol>(in);
      ranges::copy(sequence_input | ranges::view::transform(symbol_map), ranges::back_inserter(sequence));
      return sequence;
    }
} // namespace hmm
} // namespace maikel

#endif /* HMM_IO_H_ */
